# -*- coding: utf-8 -*-
"""22L-6721-6J-A2-Q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WNYhUvCrnJXConh0HxpQjxmuOO7x_bwA
"""

#Function to print the board
def print_board(board):
  for row in board:
    print(row)

#Function to generate initial board for some size
def generate_board(size):
  board = [[' ' for x in range(size * 2 + 1)] for x in range(size * 2 + 1)]

  for i in range(len(board)):
    for j in range(len(board[i])):
      if j % 2 == 1 and i % 2 == 0:
        board[i][j] = '■'
      elif j % 2 == 0 and i % 2 == 1:
        board[i][j] = '●'

  for i in range(len(board)):
    board[0][i] = board[size * 2][i] = '■'
    board[i][0] = board[i][size * 2] = '●'

  board[0][0] = board[0][size * 2] = board[size * 2][0] = board[size * 2][size * 2] = '■'

  return board

#Function to check if there exist a path from one fence to another
def check_player_win(board, start_x, start_y, char):
    rows, cols = len(board), len(board[0])
    visited = set()

    def dfs(x, y):
        if (0 <= x < rows and 0 <= y < cols) and (board[x][y] == char or board[x][y] == 'D') and not ((x, y) in visited):
          if board[x][y] == 'D':
            return True

          visited.add((x, y))
          return (dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1))

        else:
          return False

    result = dfs(start_x, start_y)
    return result

#Function to check if red player wins or not
def check_red_win(board, size):
  visited_board = [[' ' for x in range(size * 2 + 1)] for x in range(size * 2 + 1)]

  for i in range(len(board)):
    for j in range(len(board)):
      visited_board[i][j] = board[i][j]

  for i in range(len(visited_board)):
    visited_board[size * 2][i] = 'D'

  return check_player_win(visited_board, 0, 0, '■')

#Function to check if blue player wins or not
def check_blue_win(board, size):
  visited_board = [[' ' for x in range(size * 2 + 1)] for x in range(size * 2 + 1)]

  for i in range(len(board)):
    for j in range(len(board)):
      visited_board[i][j] = board[i][j]

  for i in range(1, len(visited_board) - 1):
    visited_board[i][size * 2] = 'D'

  return check_player_win(visited_board, 1, 0, '●')

#Function to check if game is drawn
def check_draw(board):
  for i in range(1, len(board) - 1):
    for j in range(1, len(board) - 1):
      if board[i][j] == ' ':
        return False
  return True

def human_move(board, size):
  flag = False
  while not flag:

    print("Enter your move (You can only move in blank space)")
    row=input(f"Enter row (1-{size*2-1}):")
    col=input(f"Enter col (1-{size*2-1}):")

    if not row.isdigit() or not col.isdigit():
      print("Invalid input")
    else:
      row = int(row)
      col = int(col)

      if row < 1 or col < 1 or row > (size*2-1) or col > (size*2-1) or board[row][col] != ' ':
        print("Invalid move")
      else:
        board[row][col] = '■'
        flag = True

from collections import deque

# Bread first search to find shortest path
def bfs(board, start_x, start_y, char):

    rows, cols = len(board), len(board[0])
    visited = set()
    queue = deque([(start_x, start_y, 0)])
    visited.add((start_x, start_y))

    while queue:
        x, y, moves = queue.popleft()

        if board[x][y] == 'D':
            return moves

        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nx, ny = x + dx, y + dy

            if (0 <= nx < rows and 0 <= ny < cols and
                    (board[nx][ny] == char or board[nx][ny] == 'D' or board[nx][ny] == ' ') and
                    (nx, ny) not in visited):
                visited.add((nx, ny))
                queue.append((nx, ny, moves + 1))

    return -1

# Calculate minimum number of moves
def calculate_min_moves(board, size, player):

    visited_board = [row[:] for row in board]

    if player == 'R':
        for i in range(len(visited_board)):
            visited_board[size * 2][i] = 'D'
        start_x, start_y = 0, 0
    else:
        for i in range(1, len(visited_board) - 1):
            visited_board[i][size * 2] = 'D'
        start_x, start_y = 1, 0

    moves = bfs(visited_board, start_x, start_y, player)

    return moves if moves != -1 else float('inf')

# Utility function that return score based on board state
def utility_function(board, size):

    if check_red_win(board, size):
        return -float('inf')
    elif check_blue_win(board, size):
        return float('inf')
    elif check_draw(board):
        return 0
    else:
        red_moves = calculate_min_moves(board, size, '■')
        blue_moves = calculate_min_moves(board, size, '●')

        return blue_moves - red_moves

#Function to maximize the score
def max_value(board, size, alpha, beta, current_depth, max_depth):
  if current_depth == max_depth:
    return utility_function(board, size), None
  else:
    best_score = -float('inf')
    best_move = None

    for i in range(1, len(board) - 1):
      for j in range(1, len(board) - 1):
        if board[i][j] == ' ':
          board[i][j] = '●'
          score, move = min_value(board, size, alpha, beta, current_depth + 1, max_depth)
          board[i][j] = ' '
          if score > best_score:
            best_score = score
            best_move = (i, j)
          alpha = max(alpha, score)
          if beta <= alpha:
            break
    return best_score,best_move

#Function to minimize thre score
def min_value(board, size, alpha, beta, current_depth, max_depth):
  if current_depth == max_depth:
    return utility_function(board, size), None
  else:
    best_score = float('inf')
    best_move = None

    for i in range(1, len(board) - 1):
      for j in range(1, len(board) - 1):
        if board[i][j] == ' ':
          board[i][j] = '■'
          score, move = max_value(board, size, alpha, beta, current_depth + 1, max_depth)
          board[i][j] = ' '
          if score < best_score:
            best_score = score
            best_move = (i, j)
          beta = min(beta, score)
          if beta <= alpha:
            break
    return best_score,best_move

#Function to perform computer move using min max algorithm
def computer_move(board, size, max_depth):
  best_score, best_move = max_value(board, size, -float('inf'), float('inf'), 0, max_depth)
  board[best_move[0]][best_move[1]] = '●'
  print(f"Computer move: {best_move[0]} {best_move[1]}")

from IPython.display import clear_output

size = 5
board = generate_board(size)
print_board(board)

while True:
  human_move(board, size)
  print_board(board)
  if check_red_win(board, size):
    print("You won the game")
    break
  computer_move(board,size, 4)
  print_board(board)
  if check_blue_win(board, size):
    print("Computer won the game")
    break
print("Game Over")